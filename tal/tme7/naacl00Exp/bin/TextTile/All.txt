#####################################################################
# Makefile
#####################################################################

CC=	gcc
PROG=	tile
SRCS=	main.c tile.c token.c common.c
OBJS=	main.o tile.o token.o common.o

LEX=	flex
CLEANFILES+= token.c

# You need to change this to whereever you have tcl installed
LDADD=  -L/usr/sww/lib -ltcl -lm -ll
CFLAGS= -I/usr/sww/include/tcl

tile: ${OBJS}
	${CC} ${CFLAGS} -o tile ${OBJS} ${LDADD}

common.c: mkcommon
	sh ./mkcommon > common.c

#####################################################################
# common_words.list
#####################################################################
a
about
above
accordingly
across
after
afterwards
again
against
all
allows
almost
alone
along
already
also
although
always
am
among
amongst
an
and
another
any
anybody
anyhow
anyone
anything
anyway
anyways
anywhere
apart
appear
appropriate
are
around
as
aside
associated
at
available
away
awfully
b
be
became
because
become
becomes
becoming
been
before
beforehand
behind
being
below
beside
besides
best
better
between
beyond
both
brief
but
by
c
came
can
cannot
cant
cause
causes
certain
certainly
change
changes
clearly
co
concerning
consequently
consider
contain
containing
contains
corresponding
could
course
currently
d
described
did
different
do
does
doing
done
down
downwards
during
e
each
eg
eight
either
else
elsewhere
enough
especially
et
etc
even
ever
every
everybody
everyone
everything
everywhere
ex
example
except
f
far
few
fifth
first
five
followed
following
follows
for
former
formerly
forth
four
from
further
furthermore
g
get
gets
given
gives
go
goes
going
gone
got
gotten
h
had
happens
hardly
has
have
having
hence
here
hereafter
hereby
herein
hereupon
herself
himself
hither
how
howbeit
however
i
i'd
i'll
i'm
i've
ie
if
ignored
immediate
in
inasmuch
inc
indeed
indicate
indicated
indicates
inner
insofar
instead
into
inward
is
it
its
it's
itself
j
just
k
keep
kept
know
knows
known
l
last
latter
latterly
least
less
lest
let
like
little
looks
ltd
m
many
may
meanwhile
might
more
moreover
most
mostly
much
must
myself
n
name
namely
near
necessary
neither
never
nevertheless
new
next
nine
no
nobody
none
noone
nor
normally
not
nothing
novel
now
nowhere
o
of
off
often
oh
old
on
once
one
ones
only
onto
or
other
others
otherwise
ought
our
ours
ourselves
out
outside
over
overall
own
p
particular
particularly
per
perhaps
placed
please
plus
possible
probably
provides
q
que
quite
r
rather
re
really
relatively
respectively
right
s
said
same
says
second
secondly
see
seem
seemed
seeming
seems
seen
self
selves
sensible
sent
serious
seven
several
shall
should
since
six
so
some
somebody
somehow
someone
something
sometime
sometimes
somewhat
somewhere
specified
specify
specifying
still
sub
such
sup
t
take
taken
than
that
thats
that's
the
their
theirs
them
themselves
then
thence
there
thereafter
thereby
therefore
therein
theres
there's
thereupon
these
they
third
this
thorough
thoroughly
those
though
three
through
throughout
thru
thus
to
together
too
toward
towards
twice
two
u
un
under
unless
until
unto
up
upon
us
use
used
useful
uses
using
usually
v
value
various
very
via
viz
vs
w
was
way
we
well
went
were
what
whatever
when
whence
whenever
where
whereafter
whereas
whereby
wherein
whereupon
wherever
whether
which
while
whither
who
whoever
whole
whom
whose
why
will
with
within
without
would
wouldn't
x
y
yes
yet
you're
yours
yourself
yourselves
z
zero
A
About
Above
Accordingly
Across
After
Afterwards
Again
Against
All
Allows
Almost
Alone
Along
Already
Also
Although
Always
Am
Among
Amongst
An
And
Another
Any
Anybody
Anyhow
Anyone
Anything
Anyway
Anyways
Anywhere
Apart
Appear
Appropriate
Are
Around
As
Aside
Associated
At
Available
Away
Awfully
B
Be
Became
Because
Become
Becomes
Becoming
Been
Before
Beforehand
Behind
Being
Below
Beside
Besides
Best
Better
Between
Beyond
Both
Brief
But
By
C
Came
Can
Cannot
Cant
Cause
Causes
Certain
Certainly
Change
Changes
Clearly
Co
Concerning
Consequently
Consider
Contain
Containing
Contains
Corresponding
Could
Course
Currently
D
Described
Did
Different
Do
Does
Doing
Done
Down
Downwards
During
E
Each
Eg
Eight
Either
Else
Elsewhere
Enough
Especially
Et
Etc
Even
Ever
Every
Everybody
Everyone
Everything
Everywhere
Ex
Example
Except
F
Far
Few
Fifth
First
Five
Followed
Following
Follows
For
Former
Formerly
Forth
Four
From
Further
Furthermore
G
Get
Gets
Given
Gives
Go
Goes
Going
Gone
Got
Gotten
H
Had
Happens
Hardly
Has
Have
Having
He
Hence
Her
Here
Hereafter
Hereby
Herein
Hereupon
Hers
Herself
Him
Himself
His
Hither
How
Howbeit
However
I
I'd
I'll
I'm
I've
Ie
If
Ignored
Immediate
In
Inasmuch
Inc
Indeed
Indicate
Indicated
Indicates
Inner
Insofar
Instead
Into
Inward
Is
It
Its
It's
Itself
J
Just
K
Keep
Kept
Know
Knows
Known
L
Last
Latter
Latterly
Least
Less
Lest
Let
Like
Little
Looks
Ltd
M
Many
May
Me
Meanwhile
Might
More
Moreover
Most
Mostly
Much
Must
My
Myself
N
Name
Namely
Near
Necessary
Neither
Never
Nevertheless
New
Next
Nine
No
Nobody
None
Noone
Nor
Normally
Not
Nothing
Novel
Now
Nowhere
O
Of
Off
Often
Oh
Old
On
Once
One
Ones
Only
Onto
Or
Other
Others
Otherwise
Ought
Our
Ours
Ourselves
Out
Outside
Over
Overall
Own
P
Particular
Particularly
Per
Perhaps
Placed
Please
Plus
Possible
Probably
Provides
Q
Que
Quite
R
Rather
Re
Really
Relatively
Respectively
Right
S
Said
Same
Says
Second
Secondly
See
Seem
Seemed
Seeming
Seems
Seen
Self
Selves
Sensible
Sent
Serious
Seven
Several
Shall
She
Should
Since
Six
So
Some
Somebody
Somehow
Someone
Something
Sometime
Sometimes
Somewhat
Somewhere
Specified
Specify
Specifying
Still
Sub
Such
Sup
T
Take
Taken
Than
That
Thats
That's
The
Their
Theirs
Them
Themselves
Then
Thence
There
Thereafter
Thereby
Therefore
Therein
Theres
There's
Thereupon
These
They
Third
This
Thorough
Thoroughly
Those
Though
Three
Through
Throughout
Thru
Thus
To
Together
Too
Toward
Towards
Twice
Two
U
Un
Under
Unless
Until
Unto
Up
Upon
Us
Use
Used
Useful
Uses
Using
Usually
V
Value
Various
Very
Via
Viz
Vs
W
Was
Way
We
Well
Went
Were
What
Whatever
When
Whence
Whenever
Where
Whereafter
Whereas
Whereby
Wherein
Whereupon
Wherever
Whether
Which
While
Whither
Who
Whoever
Whole
Whom
Whose
Why
Will
With
Within
Without
Would
Wouldn't
X
Y
Yes
Yet
You
Your
You're
Yours
Yourself
Yourselves
Z
Zero

#####################################################################
# main.c
#####################################################################

/*
 * Copyright (c) 1994
 *      The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Marti Hearst.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include "tile.h"

int	Argc;
char	**Argv;
int	f_showoffsets;

/*
 *  Main
 */
main(int argc, char **argv)
{
	TILEDOC *tdp;
	int ret = 0;

	Argc = argc;
	Argv = argv;

	tile_getopts();

	for (; *Argv; ++Argv) {
		if (verbose)
			fprintf(stderr, "processing %s\n", *Argv);
		if ((tdp = tile(*Argv, NULL)) == NULL) {
			fprintf(stderr, "tile: %s: %s\n", 
				*Argv, strerror(errno));
			ret |= 1;
			continue;
		}
		if (f_showoffsets)
			ret |= showoffsets(*Argv, tdp);
		else
			ret |= showtext(*Argv, tdp);
		freetiledoc(tdp);
	}

	exit(ret);
}

tile_getopts()
{
	int	c;
	extern char *optarg;
	extern int optind;

	while ((c = getopt(Argc, Argv, "oib:n:k:w:xpv")) != -1) {
		switch (c) {
		case 'o':
			f_showoffsets++;
			break;
		case 'i':
			indented++;
			break;
		case 'b': 
			bound = atoi(optarg);
			break;
		case 'n': 
			numiter = atoi(optarg);
			break;
		case 'k': 
			this_k = atoi(optarg);
			break;
		case 'w': 
			word_sep_num = atoi(optarg);
			break;
		case 'p': 
			not_para_boundaries = 1;
			break;
		case 'v': 
			verbose = 1;
			break;
                case '?':
                default:
                        exit(1);
		}

	}
	Argv += optind;
	Argc -= optind;
}

/*
 * output routine:
 *	show the actual text of the tiles appropiatly labeled
 */
showtext(char *fname, TILEDOC *tdp)
{
	FILE *fp;
	int tx, c;
	long i;
	TILE *tp = tdp->tilearray;

	if ((fp = fopen(fname, "r")) == NULL) {
		fprintf(stderr, "tile: can't open %s: %s\n", 
			fname, strerror(errno));
		return (1);
	}
	for (tx = 0; tx < tdp->numtiles; tx++) {
		printf("<TILE %d - FILE: %s START: %ld END: %ld>\n",
			tx, fname, tp[tx].startoff, tp[tx].endoff);
		fseek(fp, tp[tx].startoff, SEEK_SET);
		for (i = 0; i < tp[tx].endoff - tp[tx].startoff; i++) {
			c = getc(fp);
			if (c == EOF)
				break;
			(void)putc(c, stdout);
		}
		printf("</TILE %d - FILE: %s START: %ld END: %ld>\n",
			tx, fname, tp[tx].startoff, tp[tx].endoff);
	}
	fclose(fp);

	return (0);
}

/*
 * output routine:
 *	show just the tile locations
 */
showoffsets(char *fname, TILEDOC *tdp)
{
	int tx;
	TILE *tp = tdp->tilearray;

	printf("# FILE: %s\n# NUMTILES: %d\n# start	end\n",
		fname, tdp->numtiles);
	for (tx = 0; tx < tdp->numtiles; tx++) {
		printf("%ld	%ld\n",
			tdp->tilearray[tx].startoff,
			tdp->tilearray[tx].endoff);
	}

	return (0);
}

#####################################################################
# mkcommon
#####################################################################

IN="common_words.list"

echo '
/* 
 * This file generated by "mkcommon" shell script - do not edit this file.
 */

#include <stdio.h>

char *common_words[] = {'

sed 's/.*/	"&",/' $IN

echo '	NULL
};'


#####################################################################
# tile.1
#####################################################################

.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.na
.TH SH 1
.SH NAME
tile \- split a text file up into small related pieces called tiles
.SH SYNOPSIS
tile [-oiv] [-b bound] [-n numiter] [-k kval] [-w wnum] [-p nopara] file ...
.SH DESCRIPTION
.LP
The tile commend is used to partition a document into a set of
related pieces called tiles.  The main purpose of this is to allow
a finer granularity of indexing.  Software that usually indexes documents
or pages by words can now use this software to break the document up into
smaller elements of related information (tiles) and index into that.
The algorithm that determines the tiles in a document is essentially
statistical in nature and is described in a paper by Marti Hearst
entitled "Multi-Paragraph Segmentation of Expository Discourse", available
from the U.C Berkeley Computer Science Division.  A copy of that paper
has been included with the source for the tile program.
.LP
.B Overview
.sp
.LP
By default, the files are broken up into tiles and the tiles
are displayed by surrounding each with the following meta information:
.sp
.nf
	<TILE \fItilenum\fP - FILE: \fIfilename\fP START: \fIstartoff\fP END: \fIendoff\fP>
	document tile
	</TILE \fItilenum\fP - FILE: \fIfilename\fP START: \fIstartoff\fP END: \fIendoff\fP>
.sp
.fi
where \fItilenum\fP is the tile number, \fIfilename\fP is the name of the
file the tile comes from, \fIstartoff\fP and \fIendoff\fP are the starting
and endind file offsets of the tile.
.LP
If the -o flag is specified, then simply a list of file offsets for each
tile is printed, along with a self-expanatory header identifying where
the tiles come from.
.LP
.B Identifying Paragraphs
.LP
By default, the tileing tokenizer will identify paragraph breaks by
the presence of one or more blank lines.  If the text uses indented
paragraphs instead of blank lines, you can specify the -i flag so the
taokenizer will understand this.  If you have text that does something
fancier, you will have to write your own tokenizer (replace token.l).
This is not that hard, and there is a special hook so that you can
pass the main tile routine a callback function to handle special
tokens that are not part of the tilizing tokens.
.LP
The rest of the options adjust parameters that affect the tokenizing
algorithm, and unfortunatly I cannot document them currently at this time.
(marti?)


#####################################################################
# tile.c
#####################################################################

/*
 * Copyright (c) 1994
 *      The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Marti Hearst.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 *  tile - partition text into convenient sections called "tiles".
 */

/*
 *  Tilize the document contained in the file.  The default tokenizer
 *  returns tokens of type TEXT_TOKEN, to denote a word, and types
 *  BLANK_TOKEN and type INDENT_TOKEN.  BLANK_TOKEN indicates a blank
 *  line, and INDENT_TOKEN indicates a line that had whitespace prefixing
 *  it.  Based on the value of a flag, you can indicate the presence of
 *  a new paragraph by either a series of one or more blank lines (the default)
 *  or he presence of an indented line, in case this document doesn't use
 *  blank lines to break paragraphs.  Anything more complicted than that
 *  and you'll have to write your own lex tokenizer to parse your document.
 *  If any token type other than these three is encountered, and you have
 *  provided a callback function, than your function will be called with the
 *  value of the token, the text of the token if any, and the file offset
 *  it was encountered at.  This could be used for example to process
 *  files that contain multiple documents, or if you want to extract
 *  information out of the processed file (and without cluttering up the
 *  the tilizing code caontained here).  Of course you will have to write
 *  your own tokenizer to process your additional tokenss, and write the
 *  the callback funtion to do something useful with the information.
 *  After the document is completely processed, a TILEDOC structure is
 *  returned that contains the fileoffsets of the recognized tiles.
 */

/* 
 * To be honest, I don't understand this algorithm.  Comments preceded with 
 * an "@" are notes to myelf about what I think the code is doing and should 
 * not be taken as statements of fact by the original author.
 */

#include <string.h>
#include <math.h>
#include <sys/types.h>
#include <errno.h>
#include <tcl.h>
#include <assert.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/file.h>

#include "tile.h"
#include "token.h"


extern FILE	 *yyin;
extern int	token_type;
extern int	bytes;
extern char	*common_words[];
extern char 	*yytext;

#define  MAX_KEY_LEN        (256)	/* max term size */

/*
 * we grow these as we see more sentences in the document
 */
int	*Sentpara = (int *)NULL;
long	*Paralocs = (long *)NULL;	
double	*w1 = (double *)NULL;
double	*w2 = (double *)NULL;
int	*Sentarray = (int *)NULL;	/* wloc array converted to sent 
					   array  upon demand */
int	wordcount;
int	max_sent;
int	max_word;
int	max_para;

typedef struct  {
	double	val;
	int	sgap;
} SORTF;

/*
 * One of these per word stored in the tcl hash table named "TP".
 */
typedef struct AInfo {
	int	current_count;	/* # times word has been seen. */
	int	para_count;	/* # of paragraphs it's appeared in. */
	int	last_para;	/* Last paragraph it appeared in (so we know
				 * when to bump para_count */
	int	*wloc; 		/* Indexed by occurence of word.  Records
				 * the sentence # it appearded in.  Remember
				 * sentences aren't real sentences, but
				 * arbitrarily every 20 words */
	int	wlocsize;	/* grow wloc as needed */
} AInfo;


char	*yylex();
void	*yyrestart(FILE *);

/*
 * Function prototypes
 */
TILEDOC *process_input();
void cleanup_table(Tcl_HashTable *);
void compute_all_sim();
void show_sentence_stats();
void compute_sim(int, int);
void show_counts();
void process_token(Tcl_HashTable *, char *, int, int);
void align_hashkey(char *, char *);
void smooth();
TILEDOC *tile_locs();
void dobfile(char *);
void show_tile_locs();
void find_boundaries(double *);
void plot_para_boundaries(SORTF *, double);
void plot_sent_boundaries(SORTF *, double);
void show_segments();
void output_segments();
double determine_scores(double *, SORTF *);
void tile_getopts(int, char **);
int cmp(const void *, const void *);
int compsf(const void *, const void *);
void init_stopword_table();
void lower_and_stem_it(char *, char *);
int stopword(char *);
int wloc_to_sentarray(int *, int);

/*
 * Tweakable Parameters (externed in tile.h)
 */
int	bound = 2;
int	numiter = 1;
int	this_k = 4;
int	word_sep_num = 20;
int	not_para_boundaries = 0;
int	verbose = 0;
int	indented = 0;	/* process indented text as a paragraph */

Tcl_HashTable *StopTablePtr;
Tcl_HashTable *TP;

long	startoftext, endoftext;

#ifdef lint
#define printf (void)printf
#define fprintf (void)fprintf
#define sprintf (void)sprintf
#define strcpy	(void)strcpy
#define strncpy	(void)strncpy
#define strcat	(void)strcat
#endif

TILEDOC *
tile(char *fname, void (*callback)(int, char *, long))
{
	char	buf[MAX_KEY_LEN];

	int	outwordcount = 0;
	char	*str;
	int	snum = 1;
	int	para = 1;
	int	seen_para_break = 0;
	int	i;
	TILEDOC	*td;
	int cur_sentsize = 400;
#define	GROWSENT 800
	/*
	 * Reset for new doc
	 */
	mksentarrays(0, cur_sentsize);
	startoftext = bytes = 0;
	max_sent = 0;
	max_para = 0;

        if ((yyin = fopen(fname, "r")) == NULL) {
                fprintf(stderr, "Can't open %s\n", fname);
                return (TILEDOC *)NULL;
        }
	if (!StopTablePtr)
		init_stopword_table();
	if (!TP) {
		TP = (Tcl_HashTable * )malloc(sizeof(Tcl_HashTable));
		if (TP == NULL) {
			fprintf(stderr, "Out of memory\n");
			exit(1);
		}
		Tcl_InitHashTable(TP, TCL_STRING_KEYS);
	}

	while (str = yylex()) {
                if (token_type == TEXT_TOKEN) {
                        strcpy(buf, str);
			process_token(TP, buf, snum, para);
			outwordcount++;
			seen_para_break = 0;
			/*
			 * @ It looks like every 20 words (word_sep_num) we
			 * @ arbitrarily say we've seen another sentence. So
			 * @ it seems we don't care about periods or newlines.
			 * @ - strange...
			 */
			if ((outwordcount % word_sep_num) == 0)
				snum++;
                } else if (((token_type == BLANK_TOKEN) || 
		    (indented && (token_type == INDENT_TOKEN))) && 
		    (Sentpara[snum] == 0) && (Sentpara[snum-1] == 0)) {
                        if (seen_para_break == 0) {
                                Sentpara[snum] = para;
                                Paralocs[snum] = bytes;
                                para++;
                        }
                        seen_para_break = 1;
                } else if (token_type != NULL_TOKEN && callback != NULL) {
			(*callback)(token_type, yytext, bytes);
		}

		if (snum > cur_sentsize)
			mksentarrays(cur_sentsize, cur_sentsize += GROWSENT);
	}
	fclose(yyin);
	endoftext = bytes;
	max_sent = snum;
	max_para = para;

	/*
	 * Determine the tile locations.
	 */
	td = process_input();

	/*
	 * cleanup - prepare in case we have to process a new file
	 */
	cleanup_table(TP);
	TP = NULL;
	freesentarrays();
	reset_tokenizer();
	
	return (td);
}

TILEDOC *
process_input()
{
	compute_all_sim();
	smooth();
	return (tile_locs());
}

int
stopword(char *str)
{
	if (Tcl_FindHashEntry(StopTablePtr, str) == NULL)
		return (0);

	return (1);
}

void
lower_and_stem_it(char *term, char *buffer)
{
	register int	i;

	strcpy(buffer, term);
	for (i = 0; i < strlen(term) + 1; i++)
		buffer[i] = tolower(buffer[i]);

	/* 
	 * stemming removed -- we aren't doing it anymore because it
	 * didn't seem to buy us anything.  If you want to experiment
	 * with it, you can add it back here.
	 */
#ifdef notdef
	if (!(stopword(buffer)))
		strcpy(buffer, mymorph(buffer));
#endif

}

void
init_stopword_table()
{
	int	i, new;

	StopTablePtr = (Tcl_HashTable * )malloc(sizeof(Tcl_HashTable));
	if (StopTablePtr == NULL) {
		fprintf(stderr, "Out of memory\n");
		exit(1);
	}
	Tcl_InitHashTable(StopTablePtr, TCL_STRING_KEYS);

	for (i = 0; common_words[i] != NULL; i++)
		Tcl_CreateHashEntry(StopTablePtr, common_words[i], &new);
	
}

int	
compsf(const void *t1, const void *t2)
{
	
	if (((SORTF *)t1)->val > ((SORTF *)t2)->val)
		return (-1);
	if (((SORTF *)t1)->val < ((SORTF *)t2)->val)
		return (1);

	return (0);
}

int
cmp(const void *d1, const void *d2)
{
	if (*(long *)d1 < *(long *)d2)
		return (-1);
	if (*(long *)d1 > *(long *)d2)
		return (1);

	return (0);
}

/* @ return value sometimes unused */
double
determine_scores(double *w, SORTF *scores)
{
	int	i, j, sentgap;
	double	value, score;
	double	max = 0.0;

	for (i = 0; i < max_sent; i++) {
		scores[i].val = 0.0;
		scores[i].sgap = 0;
	}

	for (sentgap = 1; sentgap < max_sent; sentgap++) {
		value = w[sentgap];
		if (w[sentgap] > max)
			max = w[sentgap];

		score = 0.0;
		j = sentgap - 1;
		while (j > 1) {
			if (w[j] < value)
				break;
			value = w[j];
			j--;
		}
		score = value - w[sentgap];
		j = sentgap + 1;
		value = w[sentgap];
		while (j < max_sent) {
			if (w[j] < value)
				break;
			value = w[j];
			j++;
		}
		if ((score > 0.0) && ((value - w[sentgap]) > 0.0)) {
			score += value - w[sentgap];
			scores[sentgap].val = score;
			scores[sentgap].sgap = sentgap;
		}
	}
	return(max);
}

/*
 * @ well, this part i don't understand (marti?)
 */
void
smooth()
{
	int	i, j, k;
	double	nw;
	int	count;

	if (verbose) {
		printf("\n\n");
		for (j = 1; j < max_sent; j++) {
			printf("**** %d %.3lf\n", j, w1[j]);
		}
	}

	for (j = 1; j < this_k; j++)
		w2[j] = w1[j];
	for (j = (max_sent - this_k); j < max_sent; j++)
		w2[j] = w1[j];
	for (k = 0; k < numiter; k++) {
		for (j = this_k; j < (max_sent - this_k); j++) {
			nw = 0.0;
			count = 0;
			for (i = (-bound + 1); i < bound; i++) {
				nw += w1[j+i];
				count++;
			}
			w2[j] = nw / (double)count;
		}
		for (j = 1; j < max_sent; j++) {
			w1[j] = w2[j];
		}
	}
#ifdef notdef
	if (verbose) {
		printf("\n\n");
		for (j = 1; j < max_sent; j++) {
			printf("%d %.3lf\n", j, w2[j]);
		}
		find_boundaries(w2);
	}
#endif
}


void
align_hashkey(char *str, char *buf)	/* @ ??? */
{
	bzero(buf, MAX_KEY_LEN);
	strncpy(buf, str, strlen(str));

}

void
compute_sim(int ss, int k)
{
	double	num, w1s, w2s, s1, s2, temp;
	int	j;
	int	ss2;
	AInfo	*ip;
	Tcl_HashEntry *hp;
	Tcl_HashSearch hs, *sp;

	ss2 = ss + k;

	num = w1s = w2s = 0.0;
	sp = &hs;
	for (hp = Tcl_FirstHashEntry(TP, sp); hp;
            hp = Tcl_NextHashEntry(sp)) {
		s1 = s2 = 0.0;
		ip = (AInfo * )Tcl_GetHashValue(hp);
		wloc_to_sentarray(ip->wloc, ip->current_count);
		for (j = ss; j < (ss + k); j++) {
			s1 += Sentarray[j];
		}
		for (j = ss2; j < (ss2 + k); j++) {
			s2 += Sentarray[j];
		}
		num += s1 * s2;
		w1s += s1 * s1;
		w2s += s2 * s2;
	}
	temp = sqrt(w1s * w2s);
	w1[ss+k-1] = (temp) ?  (num / temp) : 0.0;
}

void
compute_all_sim()
{
	int	i;
	/* use a smaller amount of context at the beginning and end */
	for (i = 1; i < this_k; i++) {
		compute_sim(i, 3);
	}
	/* @ ??? - doesn't this want to start at "this_k"? */
	for (i = 1; i <= (max_sent - (this_k * 2) + 2); i++) {
		compute_sim(i, this_k);
	}
	for (i = (max_sent - this_k); i < (max_sent - 4); i++) {
		compute_sim(i, 3);
	}
}

/*
 * Convert the sentence location array (wloc) to an array indexible
 * by sentence number.
 */
wloc_to_sentarray(int *wloc, int current_count)
{
	int i;

	bzero(Sentarray, current_count * sizeof(int));

	for (i = 0; i < current_count; i++)
		Sentarray[wloc[i]]++;
}

void
cleanup_table(Tcl_HashTable *tp)
{
	Tcl_HashEntry * hp;
	Tcl_HashSearch hs, *sp;
	AInfo *tip;

	sp = &hs;

	for (hp = Tcl_FirstHashEntry(tp, sp); hp; hp = Tcl_NextHashEntry(sp)) {
		tip = (AInfo * )Tcl_GetHashValue(hp);
		if (tip != NULL) {
			free(tip->wloc);
			free(tip);
		}
		Tcl_DeleteHashEntry(hp);
	}

}

/*
 * Record the fact we saw a term.  We use a tcl hash table for no
 * better reason than it was handy at the time.  We keep track of the
 * sentence number and paragraph number it occured in.
 */
void
process_token(Tcl_HashTable *tp, char *str, int sent, int para)
{
	AInfo * infoPtr;
	Tcl_HashEntry *hp;
	int	new;
	char	term[MAX_KEY_LEN];
	char	buf[MAX_KEY_LEN];

	lower_and_stem_it(str, term);
	if (!stopword(term)) {
		align_hashkey(term, buf);	/* ??? */
		/*
		 * @@@
		 * Put term into hash table (key is term).
		 * Keep track of which sentence each instance of this term
		 * appears in.  Also, keep track of the highest numbered
		 * paragrap this term appears in.  In Tcl hash tables,
		 * you store pointers (or integers) called ClientData.
		 */
		hp = Tcl_CreateHashEntry(tp, buf, &new);
		if (!new) {
			infoPtr = (AInfo * )Tcl_GetHashValue(hp);
		} else {
			infoPtr = (AInfo * )malloc(sizeof(AInfo));
			if (infoPtr == NULL) {
				fprintf(stderr, "Out of memory\n");
				exit(1);
			}
			if ((infoPtr->wloc = (int *)malloc(sizeof(int) * 10)) 
			     == NULL) {
				fprintf(stderr, "Out of memory\n");
                                exit(1);
			}
			infoPtr->wlocsize = 10;
			infoPtr->current_count = 0;
			infoPtr->last_para = -1;
			infoPtr->para_count = 0;
		}
		if (infoPtr->current_count >= infoPtr->wlocsize) {
			infoPtr->wlocsize += 50;
			if ((infoPtr->wloc = (int *)realloc(infoPtr->wloc,
			    sizeof(int) * infoPtr->wlocsize)) == NULL) {
				fprintf(stderr, "Out of memory\n");
				exit(1);
			}
		}
		infoPtr->wloc[infoPtr->current_count] = sent;
		if (para > infoPtr->last_para) {
			infoPtr->last_para = para;
			(infoPtr->para_count)++;
		}
		(infoPtr->current_count)++;
#ifdef TRACE
fprintf(stderr, "* wrd: %s current: %d paracnt: %d lastpapr: %d wlocsize: %d\n",
			buf, infoPtr->current_count, infoPtr->para_count,
			infoPtr->last_para, infoPtr->wlocsize);
#endif
		Tcl_SetHashValue(hp, (ClientData)infoPtr);
	}
}

/*
 * Build the list of tile offset locations to be returned.
 */
TILEDOC *
tile_locs()
{
	FILE * fp;
	SORTF *scores;
	int	*used;
	register int	i, j;
	int	para, sentgap;
	long	parabyte, prev;
	int	count = 0;
	double	avg, sd, limit;
	TILEDOC	*tdp;	/* tiledoc return structure */
	TILE	*tp;	/* pointer to tilearray in TILEDOC */
	long	*bounds;
	double	*sss;

	bounds = (long *)malloc(sizeof(long) * max_para);
	if (bounds == NULL) {
		fprintf(stderr, "Out of mammarys\n");
		exit(1);
	}
	bzero(bounds, sizeof(long) * max_para);

	sss = (double *)malloc(sizeof(double) * max_para);
	if (sss == NULL) {
		fprintf(stderr, "Out of memory\n");
		exit(1);
	}
	bzero(sss, sizeof(double) * max_para);

	scores = (SORTF *)malloc(sizeof(SORTF) * max_sent);
	if (scores == NULL) {
		fprintf(stderr, "Out of memory\n");
		exit(1);
	}
	bzero(scores, sizeof(SORTF) * max_sent);
	used = (int *)malloc(sizeof(int) * max_sent);
	if (used == NULL) {
		fprintf(stderr, "Out of memory\n");
		exit(1);
	}
	bzero(used, sizeof(int) * max_sent);

	determine_scores(w2, scores);

	qsort(scores, max_sent, sizeof(SORTF), compsf);
	for (i = 0; i < max_sent; i++) {
		para = 0;
		sentgap = scores[i].sgap;
		parabyte = Paralocs[sentgap];
		for (j = 0; j < 6; j++) {
			if (Sentpara[sentgap+j] > 0) {
				para = Sentpara[sentgap+j];
				parabyte = Paralocs[sentgap+j];
				break;
			} else if (Sentpara[sentgap-j] > 0) {
				para = Sentpara[sentgap-j];
				parabyte = Paralocs[sentgap-j];
				break;
			}
		}
		if (scores[i].val > 0.0) {
			if ((used[para] != 1) && 
			    ((parabyte > startoftext) && (parabyte < endoftext))) {
				sss[para] = scores[i].val;
				bounds[para] = parabyte;
				count++;
			}
			used[para] = 1;
		} else {
			break;
		}
	}

	avg = 0.0; 
	sd = 0.0;
	for (i = 0; i < max_para; i++) {
		avg += sss[i];
	}
	avg = avg / (double)(count ? count : 1);
	for (i = 0; i < max_para; i++) {
		if (sss[i] > 0.0) {
			sd += ((sss[i] - avg) * (sss[i] - avg));
		}
	}
	if ((count - 1) <= 0)
		sd = 0;
	else
		sd = sqrt(sd / (double)(count - 1));
	limit = avg - (sd / 2.0);

	/* record tiles */

	/*
	 * Create the TILEDOC structure to return the tile information in.
	 * We create a maximum sized tilearray and then shrink it after
	 * filling it in.
	 */
	tdp = (TILEDOC *)malloc(sizeof(TILEDOC));
	if (tdp == NULL) {
		fprintf(stderr, "Out of memory\n");
		exit(1);
	}
	tdp->tilearray = tp = (TILE *)malloc(sizeof(TILE) * max_para);
	if (tdp->tilearray == NULL) {
		fprintf(stderr, "Out of memory\n");
		exit(1);
	}
	
	prev = startoftext;
	for (i = 0; i < max_para; i++) {
		if ((sss[i] > limit) && (bounds[i] > prev)) {
			tp->startoff = prev;
			tp->endoff = bounds[i];
			tp++;
			prev = bounds[i] + 1;
		}
	}
	tp->startoff = prev;
	tp->endoff = endoftext;
	tp++;

	tdp->numtiles = tp - tdp->tilearray;

	/* 
	 * Shrink tilearray now that we know how big it is.
	 */
	tdp->tilearray = realloc(tdp->tilearray, 
		((char *)tp - (char *)tdp->tilearray));

	return (tdp);
}

/*
 * grow the sentence arrays as needed
 */
int
mksentarrays(int old, int new)
{
	Sentpara = (int *)realloc(Sentpara, sizeof(int) * new);
	Paralocs = (long *)realloc(Paralocs, sizeof(long) * new);
	w1 = (double *)realloc(w1, sizeof(double) * new);
	w2 = (double *)realloc(w2, sizeof(double) * new);
	Sentarray = (int *)realloc(Sentarray, sizeof(int) * new);

	if (!Sentpara || !Paralocs || !w1 || !w2 || !Sentarray) {
		fprintf(stderr, "Out of memory\n");
		exit(1);
	}
	
	/*
	 * make sure the new part is zeroed out
	 */
	bzero(&Sentpara[old], &Sentpara[new] - &Sentpara[old]);
	bzero(&Paralocs[old], &Paralocs[new] - &Paralocs[old]);
	bzero(&w1[old], &w1[new] - &w1[old]);
	bzero(&w2[old], &w2[new] - &w2[old]);
	bzero(&Sentarray[old], &Sentarray[new] - &Sentarray[old]);
}

/*
 * Free a TILEDOC structure.  The caller of tile() calls this to
 * free the space if desired.
 */
freetiledoc(TILEDOC *tdp)
{
	if (tdp) {
		if (tdp->tilearray)
			free(tdp->tilearray);
		free(tdp);
	}
}

/*
 * Cleanup storage we used
 */
freesentarrays()
{
	if (Sentpara) {
		free(Sentpara);
		Sentpara = NULL;
	}
	if (Paralocs) {
		free(Paralocs);
		Paralocs = NULL;
	}
	if (w1) {
		free(w1);
		w1 = NULL;
	}
	if (w2) {
		free(w2);
		w2 = NULL;
	}
	if (Sentarray) {
		free(Sentarray);
		Sentarray = NULL;
	}
}

/*
 * and prepare the tokenizer for the next file, if any.
 */
reset_tokenizer() {
	extern int lastbytes;
	extern int token_seen;

	token_seen = 0;
	lastbytes = 0;
	bytes = 0;

	lex_reset();	/* have to tell lex we may want a new file */

	/* reset other crap */
	wordcount = 0;
	max_sent = 0;
	max_word = 0;
	max_para = 0;
	startoftext = endoftext = 0;
	
}

#####################################################################
# tile.h
#####################################################################

/*
 * Copyright (c) 1994
 *      The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Marti Hearst.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/types.h>

/*
 * A text tile is identified by its start and end offset
 * in the document.
 */
typedef struct _tile {
	off_t startoff;
	off_t endoff;
} TILE;

/*
 * A tileized file is returned by the tile() return in the
 * form of a count of the tiles and an array of tile offsets.
 * The structure is returned in malloced space and must be
 * freed by the caller.
 */
typedef struct _tiledoc {
	long numtiles;
	TILE *tilearray;
} TILEDOC;

extern freetiledoc(TILEDOC *);

/*
 * Tweakable Parameters (externed in tile.h)
 */
extern int     bound;
extern int     numiter;
extern int     this_k;
extern int     word_sep_num;
extern int     use_stop_list;
extern int     not_para_boundaries;
extern int     verbose;
extern int     indented;	/* consider an indented line a paragraph */

extern TILEDOC *
tile(char *, void (*)(int, char *, long));


#####################################################################
# token.h
#####################################################################

/*
 * Copyright (c) 1994
 *      The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Marti Hearst.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * Tokens the lexical analyzer can return.
 */

#define  TEXT_TOKEN         (1)		/* a word */
#define  NULL_TOKEN         (2)		/* characters not part of a 
					   word (ignore) */
#define  BLANK_TOKEN	    (3)		/* a blank line */
#define	 INDENT_TOKEN	    (4)		/* whitespace preceding text */

#####################################################################
# token.l
#####################################################################

/*
 * Copyright (c) 1994
 *      The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Marti Hearst.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/* 
  Flex code for reading in text.

  This code assumes that the text is single spaced and that paragraphs
  are separated by a blank line.  If some other structure is used, you
  need to reflect that here.

  This is a simple tokenizer for straight text.  If a document
  contains markup, or there are multiple documents in a single file,
  this is the file you would change to return the appropiate tokens.
  The directory called "tokenizers" contains two examples of more
  complicated flex code that does exactly this.
*/

%{

#include <stdio.h>

#include "token.h"

int token_type;
int token_seen = 0;

int lastbytes = 0;
int bytes = 0;
#undef YY_DECL
#define YY_DECL char *yylex(void) 
%}

TERM          [a-zA-Z]+([\-\'][a-zA-Z]+)*

%%

{TERM}                    {
                             token_seen = 1;
			     bytes += lastbytes;
			     lastbytes = yyleng;
                             token_type = TEXT_TOKEN;
		             return((char *)yytext);
		          }


^[ ]*\n                {
		     bytes += lastbytes;
		     lastbytes = yyleng;
		      if (token_seen == 1)
                         token_type = BLANK_TOKEN;
		      else
                         token_type = NULL_TOKEN;
		      return((char *)yytext);
                      }

^[ 	]+		{
		 bytes += lastbytes;
		 lastbytes = yyleng;
		token_type = INDENT_TOKEN;
		return((char *)yytext);
		}

\n|.              {
		 bytes += lastbytes;
		 lastbytes = yyleng;
                     token_type = NULL_TOKEN;
                     return((char *)yytext);

                    }
%%

lex_reset() {
	YY_NEW_FILE;
}
