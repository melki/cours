package uk.ac.man.cs.choif.extend;

import java.awt.*;
import java.awt.image.*;
import java.io.*;
import uk.co.demon.osbald.image.bmp.*;
import uk.co.demon.osbald.io.*;
/**
 * Image processing package.
 * Creation date: (08/23/99 10:51:10)
 * @author: Freddy Choi
 */
public class Imagex {
/**
 * Apply a 3x3 kernel to M. The pixel value is the sum of the values
 * generated by applying the mask.
 * @param M float[][] (Symmetric matrix)
 */
public static void convolution (float[][] M, final int[][] K) {
	/* Freak cases */
	if (M.length < 1) return;
	if (M.length == 1) M[0][0] = 0;
	
	/* Make a copy, C, of M to reduce complexity */
	float[][] C = new float[M.length][];
	// Bottom 2 rows
	C[M.length-1] = new float[M.length];
	C[M.length-2] = new float[M.length];
	int i=M.length-2, j=M.length-1;
	C[i][j] = M[j][i];
	for (; i<M.length; i++) {
		for (j=M[i].length; j-->0;) C[i][j] = M[i][j];
	}

	// Lets do the rest
	for (i=M.length-2; i-->0;) {
		j = M[i].length + 2;
		C[i] = new float[j];
		C[i][--j] = M[j][i];
		C[i][--j] = M[j][i];
		for (;j-->0;) C[i][j] = M[i][j];
	}

	/* 1. Top left corner */
	i=0; j=0;
	int i_p=i+1, j_p=j+1;
	M[i][j] = (C[i][j]*K[1][1] + C[i_p][j]*K[2][1] + C[i][j_p]*K[1][2] + C[i_p][j_p]*K[2][2]) / (float) Math.abs(K[1][1] + K[1][2] + K[2][1] + K[2][2]);

	/* 2. Bottom right corner */
	i=M.length-1; j=i;
	int i_m=i-1, j_m=j-1;
	M[i][j] = (C[i][j]*K[1][1] + C[i][j_m]*K[1][0] + C[i_m][j]*K[0][1] + C[i_m][j_m]*K[0][0]) / (float) Math.abs(K[1][1] + K[1][0] + K[0][1] + K[0][0]);

	/* 3. Bottom left corner */
	i=M.length-1; j=0;
	i_m=i-1; j_p=j+1;
	M[i][j] = (C[i][j]*K[1][1] + C[i_m][j]*K[0][1] + C[i_m][j_p]*K[0][2] + C[i][j_p]*K[1][2]) / (float) Math.abs(K[1][1] + K[0][1] + K[0][2] + K[1][2]);

	/* 4. Bottom edge */
	i=M.length-1; i_m=i-1;
	float divisor = Math.abs(K[0][0] + K[0][1] + K[0][2] + K[1][0] + K[1][1] + K[1][2]);
	for (j=i; j-->1;) {
		j_m=j-1; j_p=j+1;
		M[i][j] = (C[i][j_m]*K[1][0] + C[i][j]*K[1][1] + C[i][j_p]*K[1][2] + C[i_m][j_m]*K[0][0] + C[i_m][j]*K[0][1] + C[i_m][j_p]*K[0][2]) / divisor;
	}

	/* 5. Left edge */
	j=0; j_p=1;
	divisor = Math.abs(K[0][1] + K[1][1] + K[2][1] + K[0][2] + K[1][2] + K[2][2]);
	for (i=M.length-1; i-->1;) {
		i_m=i-1; i_p=i+1;
		M[i][j] = (C[i_m][j]*K[0][1] + C[i][j]*K[1][1] + C[i_p][j]*K[2][1] + C[i_m][j_p]*K[0][2] + C[i][j_p]*K[1][2] + C[i_p][j_p]*K[2][2]) / divisor;
	}

	/* 6. Lets do the rest, at last :-) */
	divisor = 0;
	for (i=3; i-->0;) {
		for (j=3; j-->0;) divisor += K[i][j];
	}
	divisor = Math.abs(divisor);
	for (i=M.length-1; i-->1;) {
		i_m = i-1; i_p = i+1;
		for (j=M[i].length; j-->1;) {
			j_m = j-1; j_p = j+1;
			M[i][j] = (C[i_m][j_m]*K[0][0] + C[i_m][j]*K[0][1] + C[i_m][j_p]*K[0][2] + C[i][j_m]*K[1][0] + C[i][j]*K[1][1] + C[i][j_p]*K[1][2] + C[i_p][j_m]*K[2][0] + C[i_p][j]*K[2][1] + C[i_p][j_p]*K[2][2]) / divisor;
		}
	}
}
/**
 * Apply convolution (3x3 kernel), the pixel value is the average
 * value after convolution.
 * @param M float[][] (Symmetric matrix)
 */
public static void convolution_average (float[][] M, final int[][] K) {
	/* Freak cases */
	if (M.length < 1) return;
	if (M.length == 1) M[0][0] = 0;
	
	/* Make a copy, C, of M to reduce complexity */
	float[][] C = new float[M.length][];
	// Bottom 2 rows
	C[M.length-1] = new float[M.length];
	C[M.length-2] = new float[M.length];
	int i=M.length-2, j=M.length-1;
	C[i][j] = M[j][i];
	for (; i<M.length; i++) {
		for (j=M[i].length; j-->0;) C[i][j] = M[i][j];
	}

	// Lets do the rest
	for (i=M.length-2; i-->0;) {
		j = M[i].length + 2;
		C[i] = new float[j];
		C[i][--j] = M[j][i];
		C[i][--j] = M[j][i];
		for (;j-->0;) C[i][j] = M[i][j];
	}

	/* 1. Top left corner */
	i=0; j=0;
	int i_p=i+1, j_p=j+1;
	M[i][j] = (C[i][j]*K[1][1] + C[i_p][j]*K[2][1] + C[i][j_p]*K[1][2] + C[i_p][j_p]*K[2][2]) / (float) 4;

	/* 2. Bottom right corner */
	i=M.length-1; j=i;
	int i_m=i-1, j_m=j-1;
	M[i][j] = (C[i][j]*K[1][1] + C[i][j_m]*K[1][0] + C[i_m][j]*K[0][1] + C[i_m][j_m]*K[0][0]) / (float) 4;

	/* 3. Bottom left corner */
	i=M.length-1; j=0;
	i_m=i-1; j_p=j+1;
	M[i][j] = (C[i][j]*K[1][1] + C[i_m][j]*K[0][1] + C[i_m][j_p]*K[0][2] + C[i][j_p]*K[1][2]) / (float) 4;

	/* 4. Bottom edge */
	i=M.length-1; i_m=i-1;
	for (j=i; j-->1;) {
		j_m=j-1; j_p=j+1;
		M[i][j] = (C[i][j_m]*K[1][0] + C[i][j]*K[1][1] + C[i][j_p]*K[1][2] + C[i_m][j_m]*K[0][0] + C[i_m][j]*K[0][1] + C[i_m][j_p]*K[0][2]) / (float) 6;
	}

	/* 5. Left edge */
	j=0; j_p=1;
	for (i=M.length-1; i-->1;) {
		i_m=i-1; i_p=i+1;
		M[i][j] = (C[i_m][j]*K[0][1] + C[i][j]*K[1][1] + C[i_p][j]*K[2][1] + C[i_m][j_p]*K[0][2] + C[i][j_p]*K[1][2] + C[i_p][j_p]*K[2][2]) / (float) 6;
	}

	/* 6. Lets do the rest, at last :-) */
	for (i=M.length-1; i-->1;) {
		i_m = i-1; i_p = i+1;
		for (j=M[i].length; j-->1;) {
			j_m = j-1; j_p = j+1;
			M[i][j] = (C[i_m][j_m]*K[0][0] + C[i_m][j]*K[0][1] + C[i_m][j_p]*K[0][2] + C[i][j_m]*K[1][0] + C[i][j]*K[1][1] + C[i][j_p]*K[1][2] + C[i_p][j_m]*K[2][0] + C[i_p][j]*K[2][1] + C[i_p][j_p]*K[2][2]) / (float) 9;
		}
	}
}
/**
 * PhotoShop's implementation of the convolution process.
 * @param M float[][] Similarity matrix (Symmetric matrix)
 * @param K int[][] Kernel
 */
public static void convolution_ps (float[][] M, final int[][] K) {
	/* Create a copy of M with the boundaries defined
	so the standard convolution algorithm can be applied */
	float[][] R = new float[M.length+K.length-1][];
	for (int i=K.length, Ri=R.length; i-->0;) R[--Ri] = new float[M.length+K.length-1];
	for (int Ri=R.length-K.length; Ri-->0;) R[Ri] = new float[Ri+K.length];

	// 1. Copy M into R
	final int offset=(K.length-1)/2;
	for (int i=M.length; i-->0;) {
		for (int j=M[i].length; j-->0;) {
			R[i+offset][j+offset] = M[i][j];
		}
	}
	// 2. Initialise corners
	// 2a. Top-left
	float v = M[0][0];
	for (int i=offset; i-->0;) {
		for (int j=offset; j-->0;) R[i][j] = v;
	}
	// 2b. Bottom-left
	v = M[M.length-1][0];
	for (int i=R.length-offset; i<R.length; i++) {
		for (int j=offset; j-->0;) R[i][j] = v;
	}
	// 2c. Bottom-right
	v = M[M.length-1][M.length-1];
	for (int i=R.length-offset; i<R.length; i++) {
		for (int j=R.length-offset; j<R.length; j++) R[i][j] = v;
	}
	// 3. Initialise edges
	// 3a. Bottom
	for (int j=R.length-offset; j-->offset;) {
		v = M[M.length-1][j-offset];
		for (int i=R.length-offset; i<R.length; i++) R[i][j] = v;
	}
	// 3b. Left
	for (int i=R.length-offset; i-->offset;) {
		v = M[i-offset][0];
		for (int j=offset; j-->0;) R[i][j] = v;
	}
	// 4. Initialise off diagonal
	for (int i=R.length-offset; i-->0;) {
		for (int j=R[i].length-offset-1; j<R[i].length; j++) {
			R[i][j] = R[j][i];
		}
	}

	/* Well that was near impossible, bloody offsets allover the
	shop :-(. Anyway, lets do convolution */
	for (int i=M.length; i-->0;) {
		for (int j=M[i].length; j-->0;) {
			v = 0;
			for (int ki=K.length, Ri; ki-->0;) {
				Ri = i + ki;
				for (int kj=K[ki].length; kj-->0;) {
					v += R[Ri][j+kj] * K[ki][kj];
				}
			}
			M[i][j] = (v > 0 ? v : 0);
		}
	}
}
/**
 * Make a copy of M.
 * @return float[][]
 * @param M float[][]
 */
public static final float[][] copy (final float[][] M) {
	float[][] C = new float[M.length][];
	for (int i=M.length; i-->0;) {
		C[i] = new float[M[i].length];
		System.arraycopy(M[i], 0, C[i], 0, M[i].length);
	}
	return C;
}
/**
 * Apply hard ranking to clean up image. This replaces each pixel
 * with the number of pixels that have a smaller value (range 0..8).
 * This is then scaled to range 0.0..1.0. For pixels at the edges,
 * we do the same but scale according to the number of pixels
 * available for comparisons (corner = 3, edge = 5).
 * @param M float[][] (Symmetric matrix)
 */
public static void hardRanking (float[][] M) {
	/* Freak cases */
	if (M.length < 1) return;
	if (M.length == 1) M[0][0] = 1;
	
	/* Make a copy, C, of M (symmetric) to reduce complexity.
	The values required by the process that are not in the symmetric
	matrix (e.g. the other side of the diagonal) are copied to simplify
	computation. */
	float[][] C = new float[M.length][];
	// Bottom 2 rows
	C[M.length-1] = new float[M.length];
	C[M.length-2] = new float[M.length];
	int i=M.length-2, j=M.length-1;
	C[i][j] = M[j][i];
	for (; i<M.length; i++) {
		for (j=M[i].length; j-->0;) C[i][j] = M[i][j];
	}

	// Lets do the rest
	for (i=M.length-2; i-->0;) {
		j = M[i].length + 2;
		C[i] = new float[j];
		C[i][--j] = M[j][i];
		C[i][--j] = M[j][i];
		for (;j-->0;) C[i][j] = M[i][j];
	}

	/* 1. Top left corner */
	i=0; j=0;
	int i_p=i+1, j_p=j+1;
	float p = C[i][j];
	M[i][j] = ((p > C[i_p][j] ? 1 : 0) + (p > C[i][j_p] ? 1 : 0) + (p > C[i_p][j_p] ? 1 : 0)) / (float) 3;

	/* 2. Bottom right corner */
	i=M.length-1; j=i;
	int i_m=i-1, j_m=j-1;
	p = C[i][j];
	M[i][j] = ((p > C[i][j_m] ? 1 : 0) + (p > C[i_m][j] ? 1 : 0) + (p > C[i_m][j_m] ? 1 : 0)) / (float) 3;

	/* 3. Bottom left corner */
	i=M.length-1; j=0;
	i_m=i-1; j_p=j+1;
	p = C[i][j];
	M[i][j] = ((p > C[i_m][j] ? 1 : 0) + (p > C[i_m][j_p] ? 1 : 0) + (p > C[i][j_p] ? 1 : 0)) / (float) 3;

	/* 4. Bottom edge */
	i=M.length-1; i_m=i-1;
	for (j=i; j-->1;) {
		j_m=j-1; j_p=j+1;
		p = C[i][j];
		M[i][j] = ((p > C[i][j_m] ? 1 : 0) + (p > C[i][j_p] ? 1 : 0) + (p > C[i_m][j_m] ? 1 : 0) + (p > C[i_m][j] ? 1 : 0) + (p > C[i_m][j_p] ? 1 : 0)) / (float) 5;
	}

	/* 5. Left edge */
	j=0; j_p=1;
	for (i=M.length-1; i-->1;) {
		i_m=i-1; i_p=i+1;
		p = C[i][j];
		M[i][j] = ((p > C[i_m][j] ? 1 : 0) + (p > C[i_m][j_p] ? 1 : 0) + (p > C[i][j_p] ? 1 : 0) + (p > C[i_p][j] ? 1 : 0) + (p > C[i_p][j_p] ? 1 : 0)) / (float) 5;
	}

	/* 6. Lets do the rest, at last :-) */
	for (i=M.length-1; i-->1;) {
		i_m = i-1; i_p = i+1;
		for (j=M[i].length; j-->1;) {
			j_m = j-1; j_p = j+1;
			p = C[i][j];
			M[i][j] = ((p > C[i_m][j_m] ? 1 : 0) + (p > C[i_m][j] ? 1 : 0) + (p > C[i_m][j_p] ? 1 : 0) + (p > C[i][j_m] ? 1 : 0) + (p > C[i][j_p] ? 1 : 0) + (p > C[i_p][j_m] ? 1 : 0) + (p > C[i_p][j] ? 1 : 0) + (p > C[i_p][j_p] ? 1 : 0)) / (float) 8;
		}
	}
}
/**
 * For each pixel, compute the proportion of surrounding pixels with less
 * value than the center pixel.
 * @param M float[][] (Symmetric matrix)
 */
public static void lessThan (float[][] M) {
	/* Freak cases */
	if (M.length < 1) return;
	if (M.length == 1) M[0][0] = 0;
	
	/* Make a copy, C, of M to reduce complexity */
	float[][] C = new float[M.length][];
	// Bottom 2 rows
	C[M.length-1] = new float[M.length];
	C[M.length-2] = new float[M.length];
	int i=M.length-2, j=M.length-1;
	C[i][j] = M[j][i];
	for (; i<M.length; i++) {
		for (j=M[i].length; j-->0;) C[i][j] = M[i][j];
	}

	// Lets do the rest
	for (i=M.length-2; i-->0;) {
		j = M[i].length + 2;
		C[i] = new float[j];
		C[i][--j] = M[j][i];
		C[i][--j] = M[j][i];
		for (;j-->0;) C[i][j] = M[i][j];
	}

	/* 1. Top left corner */
	i=0; j=0;
	int i_p=i+1, j_p=j+1;
	float p = C[i][j];
	M[i][j] = ((p < C[i_p][j] ? 1 : 0) + (p < C[i][j_p] ? 1 : 0) + (p < C[i_p][j_p] ? 1 : 0)) / (float) 3;

	/* 2. Bottom right corner */
	i=M.length-1; j=i;
	int i_m=i-1, j_m=j-1;
	p = C[i][j];
	M[i][j] = ((p < C[i][j_m] ? 1 : 0) + (p < C[i_m][j] ? 1 : 0) + (p < C[i_m][j_m] ? 1 : 0)) / (float) 3;

	/* 3. Bottom left corner */
	i=M.length-1; j=0;
	i_m=i-1; j_p=j+1;
	p = C[i][j];
	M[i][j] = ((p < C[i_m][j] ? 1 : 0) + (p < C[i_m][j_p] ? 1 : 0) + (p < C[i][j_p] ? 1 : 0)) / (float) 3;

	/* 4. Bottom edge */
	i=M.length-1; i_m=i-1;
	for (j=i; j-->1;) {
		j_m=j-1; j_p=j+1;
		p = C[i][j];
		M[i][j] = ((p < C[i][j_m] ? 1 : 0) + (p < C[i][j_p] ? 1 : 0) + (p < C[i_m][j_m] ? 1 : 0) + (p < C[i_m][j] ? 1 : 0) + (p < C[i_m][j_p] ? 1 : 0)) / (float) 5;
	}

	/* 5. Left edge */
	j=0; j_p=1;
	for (i=M.length-1; i-->1;) {
		i_m=i-1; i_p=i+1;
		p = C[i][j];
		M[i][j] = ((p < C[i_m][j] ? 1 : 0) + (p < C[i_m][j_p] ? 1 : 0) + (p < C[i][j_p] ? 1 : 0) + (p < C[i_p][j] ? 1 : 0) + (p < C[i_p][j_p] ? 1 : 0)) / (float) 5;
	}

	/* 6. Lets do the rest, at last :-) */
	for (i=M.length-1; i-->1;) {
		i_m = i-1; i_p = i+1;
		for (j=M[i].length; j-->1;) {
			j_m = j-1; j_p = j+1;
			p = C[i][j];
			M[i][j] = ((p < C[i_m][j_m] ? 1 : 0) + (p < C[i_m][j] ? 1 : 0) + (p < C[i_m][j_p] ? 1 : 0) + (p < C[i][j_m] ? 1 : 0) + (p < C[i][j_p] ? 1 : 0) + (p < C[i_p][j_m] ? 1 : 0) + (p < C[i_p][j] ? 1 : 0) + (p < C[i_p][j_p] ? 1 : 0)) / (float) 8;
		}
	}
}
/**
 * Make all values in M into binary values by thresholding. All
 * values > cutoff = 1 else 0.
 * @param M float[][]
 * @param cutoff float
 */
public static final void makeBinary (float[][] M, final float cutoff) {
	for (int i=M.length; i-->0;) {
		for (int j=M[i].length; j-->0;) {
			M[i][j] = (M[i][j] > cutoff ? 1 : 0);
		}
	}
}
/**
 * Calculate the mean of value of the value in the symmetric matrix M.
 * @return float
 * @param M float[][] (Symmetric matrix)
 */
public static final float mean (final float[][] M) {
	float sum=0;
	/* Lets do the diagonal first because these need to be halved */
	for (int i=M.length; i-->0;) sum+=M[i][i];
	sum = sum / (float) 2;

	/* Now do the rest */
	for (int i=M.length; i-->1;) {
		for (int j=M[i].length-1; j-->1;) {
			sum += M[i][j];
		}
	}

	/* Compute area */
	float area = (M.length * M.length) / (float) 2;

	/* Return mean */
	return sum / area;
}
/**
 * Apply local smoothing prior to thresholding by the mean value
 * of the smoothed similarity matrix.
 * @return float[][]
 * @param SIM float[][]
 */
public static final float[][] noiseReduction (final float[][] SIM) {
	/* Create noise map */
	/* Setup a 5x5 kernel for noise detection
	-1 -1 -1 -1 -1
	-1 -1 -1 -1 -1
	-1 -1  1 -1 -1
	-1 -1 -1 -1 -1
	-1 -1 -1 -1 -1 */
	int[][] kernel = new int[5][];
	kernel[0] = new int[]{-1,-1,-1,-1,-1};
	kernel[1] = new int[]{-1,-1,-1,-1,-1};
	kernel[2] = new int[]{-1,-1,1,-1,-1};
	kernel[3] = new int[]{-1,-1,-1,-1,-1};
	kernel[4] = new int[]{-1,-1,-1,-1,-1};
	
	float[][] noise_map = copy(SIM);
	convolution_ps(noise_map, kernel);
	makeBinary(noise_map, 0);

	/* Subtract noise map from original image */
	float[][] SIM_COPY = copy(SIM);
	subtract(SIM_COPY, noise_map);
	threshold(SIM_COPY, 0);
	return SIM_COPY;
}
/**
 * Scale the values in M to the range 1..0
 * @param M float[][]
 */
public static final void normalize (float[][] M) {
	/* Find maximum and minimum */
	float max=Float.MIN_VALUE, min=Float.MAX_VALUE;
	for (int i=M.length; i-->0;) {
		for (int j=M[i].length; j-->0;) {
			if (M[i][j] > max) max = M[i][j];
			if (M[i][j] < min) min = M[i][j];
		}
	}

	/* Scale values */
	float denominator = max - min;
	for (int i=M.length; i-->0;) {
		for (int j=M[i].length; j-->0;) {
			M[i][j] = (M[i][j] - min) / denominator;
		}
	}
}
/**
 * Apply hard ranking (replace pixel value with the proportion 
 * of neighbouring values its greater than) to a symmetric matrix M
 * using a S x S mask.
 * Creation date: (11/02/99 00:05:01)
 * @param M float[][] (Symmetric matrix)
 * @param S int
 */
public final static void rank(float[][] M, final int S) {
	/* Make a full matrix out of M to simplify computation */
	final float[][] F = symmetricToFull(M);

	/* Compute the offset used for mask */
	final int dS = (S % 2 == 1 ? S / 2 : (S-1) / 2);


	/* Work on M, refers to F */
	int K_is, K_ie, K_js, K_je;
	float v, sum;
	for (int M_i=M.length; M_i-->0;) {
		for (int M_j=M[M_i].length; M_j-->0;) {
			v = M[M_i][M_j]; // Grab pixel value
			M[M_i][M_j] = 0; // Set it to 0

			/* Compute effective mask range */
			K_is = M_i - dS; if (K_is < 0) K_is = 0;
			K_ie = M_i + dS + 1; if (K_ie > F.length) K_ie = F.length;
			K_js = M_j - dS; if (K_js < 0) K_js = 0;
			K_je = M_j + dS + 1; if (K_je > F.length) K_je = F.length;

			/* Compute active mask region area for normalization. Subtract 1
			because we ignore the middle pixel which will always be rank 0. */
			sum = (K_ie - K_is) * (K_je - K_js) - 1;

			/* Perform ranking */
			for (int K_i=K_ie; K_i-- > K_is;) {
				for (int K_j=K_je; K_j-- > K_js;) {
					if (v > F[K_i][K_j]) M[M_i][M_j]++;
				}
			}

			M[M_i][M_j] /= sum;
		}
	}
}
/**
 * Multiply each value in M by factor. If the product is greater than
 * the cutoff value, it is set to the cutoff value.
 * @param M float[][]
 * @param factor float
 */
public static final void scale (float[][] M, final float factor, final float cutoff) {
	float product;
	for (int i=M.length; i-->0;) {
		for (int j=M[i].length; j-->0;) {
			product = M[i][j] * factor;
			M[i][j] = (product > cutoff ? cutoff : product);
		}
	}
}
/**
 * Apply local smoothing to the similarity matrix.
 * @return float[][]
 * @param SIM float[][]
 */
public static final float[][] smooth (final float[][] SIM) {
	float[][] SIM_COPY = copy(SIM);

	/* Setup a 3x3 kernel
	1 2 1
	2 8 2
	1 2 1 */
	int[][] kernel = new int[3][3];
	kernel[0][0] = 1;
	kernel[0][1] = 2;
	kernel[0][2] = 1;
	kernel[1][0] = 2;
	kernel[1][1] = 8;
	kernel[1][2] = 2;
	kernel[2][0] = 1;
	kernel[2][1] = 2;
	kernel[2][2] = 1;

	convolution(SIM_COPY, kernel);
	return SIM_COPY;
}
/**
 * Subtract N from M, M is modified in the process.
 * @param M float[][]
 * @param N float[][]
 */
public static final void subtract (float[][] M, final float[][] N) {
	for (int i=M.length; i-->0;) {
		for (int j=M[i].length; j-->0;) {
			M[i][j]-=N[i][j];
		}
	}
}
/**
 * Convert a symmetric matrix into a complete matrix
 * Creation date: (11/01/99 23:33:47)
 * @return float[][]
 * @param M float[][] (Symmetric matrix)
 */
public final static float[][] symmetricToFull(float[][] M) {
	try {
		float[][] R = new float[M.length][M.length];
		for (int i=M.length; i-->0;) {
			System.arraycopy(M[i], 0, R[i], 0, M[i].length);
			for (int j=M[i].length; j-->0;) R[j][i] = M[i][j];
		}
		return R;
	}
	catch (Throwable e) {
		Debugx.handle(e);
		return null;
	}
}
/**
 * All values in M that are less than the cutoff value is set to 0.
 * @param M float[][]
 * @param cutoff float
 */
public static final void threshold (float[][] M, final float cutoff) {
	for (int i=M.length; i-->0;) {
		for (int j=M[i].length; j-->0;) {
			if (M[i][j] < cutoff) M[i][j] = 0;
		}
	}
}
/**
 * Compute the mean value of a similarity matrix. This value is then used
 * as a threshold to make all values in the similarity matrix binary, i.e.
 * value > threshold = 1 else 0.
 * @return float[][]
 * @param SIM float[][] (Symmetric matrix)
 */
public static final float[][] threshold_by_mean (final float[][] SIM) {
	float[][] SIM_COPY = copy(SIM);
	threshold(SIM_COPY, mean(SIM));
	return SIM_COPY;
}
/**
 * Write image to disk as a bitmap file
 * Creation date: (11/02/99 01:16:58)
 * @param M float[][]
 * @param F java.io.File
 */
public final static void writeBmp(float[][] M, File F) {
	/* Generate image */
	final int rows = M.length;
	final int columns = M[0].length;

	int[] pixels = new int[rows*columns];

	for (int i=0; i<rows; i++) {
		for (int j=0; j<columns; j++) {
			pixels[(i*columns)+j] = (new Color(M[i][j],M[i][j],M[i][j])).getRGB();
		}
	}
	
	Image I = (new Panel()).createImage(new MemoryImageSource(columns, rows, pixels, 0, columns));
	BMP bmp = new BMP(I);
	bmp.write(F);
}
}
